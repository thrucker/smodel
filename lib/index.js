// Generated by CoffeeScript 1.8.0
(function() {
  module.exports = function() {
    var model;
    return model = (function() {
      model.attrs = [];

      model.defaults = {};

      model.getter = {};

      model.setter = {};

      model.attr = function(name, opts) {
        this.attrs.push(name);
        if (opts != null ? opts["default"] : void 0) {
          this.defaults[name] = opts["default"];
        }
        if (opts != null ? opts.getter : void 0) {
          this.getter[name] = opts.getter;
        }
        if (opts != null ? opts.setter : void 0) {
          this.setter[name] = opts.setter;
        }
        return this;
      };

      function model(data) {
        var attr, props, _fn, _i, _len, _ref;
        props = {};
        _ref = this.constructor.attrs;
        _fn = (function(_this) {
          return function(attr) {
            var _arrayObserveCallback, _getter, _observeIfArray, _setter, _value;
            _value = data[attr];
            if (!_value && _this.constructor.defaults[attr]) {
              _value = JSON.parse(JSON.stringify(_this.constructor.defaults[attr]));
            }
            _arrayObserveCallback = function(changes) {
              var change, i, observer, removed, _j, _k, _l, _len1, _len2, _ref1, _ref2, _ref3, _results;
              _results = [];
              for (_j = 0, _len1 = changes.length; _j < _len1; _j++) {
                change = changes[_j];
                if (change.type !== 'splice') {
                  continue;
                }
                for (i = _k = _ref1 = change.index, _ref2 = change.index + change.addedCount; _ref1 <= _ref2 ? _k < _ref2 : _k > _ref2; i = _ref1 <= _ref2 ? ++_k : --_k) {
                  _ref3 = _this._getArrayObserversForAttribute(attr, 'add');
                  for (_l = 0, _len2 = _ref3.length; _l < _len2; _l++) {
                    observer = _ref3[_l];
                    observer(change.object[i], i);
                  }
                }
                _results.push((function() {
                  var _len3, _m, _ref4, _results1;
                  _ref4 = change.removed;
                  _results1 = [];
                  for (_m = 0, _len3 = _ref4.length; _m < _len3; _m++) {
                    removed = _ref4[_m];
                    _results1.push((function() {
                      var _len4, _n, _ref5, _results2;
                      _ref5 = this._getArrayObserversForAttribute(attr, 'remove');
                      _results2 = [];
                      for (_n = 0, _len4 = _ref5.length; _n < _len4; _n++) {
                        observer = _ref5[_n];
                        _results2.push(observer(removed));
                      }
                      return _results2;
                    }).call(this));
                  }
                  return _results1;
                }).call(_this));
              }
              return _results;
            };
            _observeIfArray = function() {
              if (Object.prototype.toString.call(_value) === '[object Array]') {
                return Array.observe(_value, _arrayObserveCallback);
              }
            };
            _observeIfArray();
            _getter = _this.constructor.getter[attr];
            if (!_getter) {
              _getter = function() {
                return _value;
              };
            }
            _setter = _this.constructor.setter[attr];
            if (!_setter) {
              _setter = function(value) {
                return _value = value;
              };
            }
            return props[attr] = {
              enumerable: true,
              get: _getter,
              set: function(value) {
                Object.getNotifier(this).notify({
                  type: 'update',
                  name: attr,
                  oldValue: _value
                });
                if (Object.prototype.toString.call(_value) === '[object Array]') {
                  Array.unobserve(_value, _arrayObserveCallback);
                }
                _setter(value);
                _observeIfArray();
              }
            };
          };
        })(this);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          attr = _ref[_i];
          _fn(attr);
        }
        Object.defineProperties(this, props);
      }

      model.prototype._getArrayObserversForAttribute = function(attr, type) {
        var _base, _base1;
        if (this._arrayObservers == null) {
          this._arrayObservers = {};
        }
        if ((_base = this._arrayObservers)[attr] == null) {
          _base[attr] = {};
        }
        if ((_base1 = this._arrayObservers[attr])[type] == null) {
          _base1[type] = [];
        }
        return this._arrayObservers[attr][type];
      };

      model.prototype.on = function(event, cb) {
        var match, _ref, _ref1;
        match = /^(\S+):(\S+)$/.exec(event);
        if (match) {
          if ((_ref = match[2]) === 'add' || _ref === 'remove') {
            this._getArrayObserversForAttribute(match[1], match[2]).push(cb);
          } else if ((_ref1 = match[2]) === 'update') {
            return Object.observe(this, (function(_this) {
              return function(changes) {
                var change, _i, _len;
                for (_i = 0, _len = changes.length; _i < _len; _i++) {
                  change = changes[_i];
                  if (event === ("" + change.name + ":" + change.type)) {
                    cb(_this[change.name]);
                    return;
                  }
                }
              };
            })(this));
          }
        }
      };

      return model;

    })();
  };

}).call(this);
